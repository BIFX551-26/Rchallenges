---
title: Flow Control - Exercises + Data Structures (continued)
author: "Student Name"
date: February 16, 2026
format: docx
---

## Data Structures (continued from last week)

#### Challenge 7

Given the following code:

```{r}
m <- matrix(1:18, nrow=3, ncol=6)
```

Which of the following commands will extract the values 11 and 14?

1. `m[2,4,2,5]`

2. `m[2:5]`

3. `m[4:5,2]`

4. `m[2,c(4,5)]`

Your answer: 

#### Challenge 8

Given the following list:

```{r}
xlist <- list(a = "Software Carpentry", b = 1:10, data = head(mtcars))
```

Using your knowledge of both list and vector subsetting, extract the number 2 from xlist.

```{r}
# your command goes here
```

#### Challenge 9

Given a linear model:

```{r}
mod <- aov(pop ~ lifeExp, data=gapminder)
```

Extract the residual degrees of freedom (hint: `attributes()` will help you).

```{r}
# your command goes here
```

#### Challenge 10

Fix each of the following common data frame subsetting errors:

```{r}
# Extract observations collected for the year 1957
gapminder[gapminder$year = 1957,]

# Extract all columns except 1 through to 4
gapminder[,-1:4]

# Extract the rows where the life expectancy is longer the 80 years
gapminder[gapminder$lifeExp > 80]

# Extract the first row, and the fourth and fifth columns (continent and lifeExp).
gapminder[1, 4, 5]

# Advanced: extract rows that contain information for the years 2002 and 2007
gapminder[gapminder$year == 2002 | 2007,]
```

#### Challenge 11

Why does `gapminder[1:20]` return an error? How does it differ from `gapminder[1:20, ]`?

*Your answer goes here.*

Create a new data.frame called `gapminder_small` that only contains rows 1 through 9 and 19 through 23. You can do this in one or two steps.

```{r}
# your commands go here
```

## Flow Control

#### Challenge 1

Use an `if()` statement to print a suitable message reporting whether there are any records from 2002 in the gapminder dataset. Now do the same for 2012.

```{r}
# your commands go here
```

#### Challenge 2

Below are the results from a few of the nested loops we just explored. Compare the output if we coerce `results_mat` to a vector.

```{r}
results_vec <- character(9)  # pre-allocate a character vector
index <- 0  # initialize an index variable
for (i in 1:3) {
  for (j in 1:3) {
    index <- index + 1  # increment the index
    results_vec[index] <- paste(i, "x", j, "=", i * j)
  }
}

results_vec

results_mat <- matrix(character(1), nrow = 3, ncol = 3)  # pre-allocate a character matrix
for (i in 1:3) {
  for (j in 1:3) {
    results_mat[i,j] <- paste(i, "x", j, "=", i * j)
  }
}

as.vector(results_mat)
```

Are they the same? If not, why not?

*your answer goes here*

How would you change the last block of code to make `as.vector(results_mat)` the same as `results_vec`?

```{r}
results_mat <- matrix(character(1), nrow = 3, ncol = 3)  # pre-allocate a character matrix
for (i in 1:3) {
  for (j in 1:3) {
    results_mat[i,j] <- paste(i, "x", j, "=", i * j)
  }
}

as.vector(results_mat)
```

#### Challenge 3

Write a script that loops through the `gapminder` data by continent and prints out whether the mean life expectancy is smaller or larger than 50 years.

```{r}
# your commands go here
```

#### Challenge 4

Modify the script from Challenge 3 to loop over each country. This time print out whether the life expectancy is smaller than 50, between 50 and 70, or greater than 70.

```{r}
# your commands go here
```

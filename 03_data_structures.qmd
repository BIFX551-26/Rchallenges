---
title: Data Structures - Exercises
author: "Student Name"
date: February 9, 2026
format: docx
---

These exercises follow along closely with [Exploring Data Frames](https://swcarpentry.github.io/r-novice-gapminder/05-data-structures-part2.html) and [Subsetting Data](https://swcarpentry.github.io/r-novice-gapminder/06-data-subsetting.html) modules of [R for Reproducible Research](https://swcarpentry.github.io/r-novice-gapminder/index.html), provided by the [Software Carpentry](https://software-carpentry.org/) community under the creative commons license, [CC-BY 4.0](https://creativecommons.org/licenses/by/4.0/). For more information see [The Carpentries](https://carpentries.org/).

## Data Structures

#### Challenge 1

Reminder: you can create a new data frame right from within R with the following syntax:

```{r}
#| eval: false
df <- data.frame(id = c("a", "b", "c"),
                 x = 1:3,
                 y = c(TRUE, TRUE, FALSE))
```

Make a data frame that holds the following information for yourself:

* first name
* last name
* lucky number
* Then use rbind to add an entry for the people sitting beside you.
* Finally, use cbind to add a column with each person’s answer to the question, "Is it time for coffee break?"
* Bonus: can you do all of this in a single command, using the `|>` operator?

```{r}
# your commands go here
```

#### Challenge 2

It’s good practice to check the first few lines last few lines of your data and some in the middle. How would you do this?

```{r}
library(gapminder)

# check the first few lines
# check the last few lines
# check some lines in the middle
```

Searching for ones specifically in the middle isn’t too hard, but we could ask for a few lines at random. How would you code this?

```{r}
# check a few lines at random
```

#### Challenge 3

Read the output of str(gapminder) again; this time, use what you’ve learned about lists and vectors, as well as the output of functions like colnames and dim to explain what everything that str prints out for gapminder means. If there are any parts you can’t interpret, discuss with your neighbors!

```{r}
str(gapminder)
```

Your answer goes here.

## Subsetting Data

#### Challenge 4

Given the following code:

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
print(x)
```

Come up with at least 2 different commands that will produce the following output:

```
  b   c   d
6.2 7.1 4.8 
```

```{r}
# your commands go here
```

#### Challenge 5

Given the following vector:

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
```

Write a subsetting command to return the values in `x` that are greater than 4 *and* less than 7.

```{r}
# your command goes here
```

#### Challenge 6

Selecting elements of a vector that match any of a list of components is a very common data analysis task. For example, the gapminder data set contains `country` and `continent` variables, but no information between these two scales. Suppose we want to pull out information from southeast Asia: how do we set up an operation to produce a logical vector that is TRUE for all of the countries in southeast Asia and FALSE otherwise?

Suppose you have these data:

```{r}
seAsia <- c("Myanmar","Thailand","Cambodia","Vietnam","Laos")
```

There are three ways we might try to do this:

* The a wrong way (using only `==`), which will give you a warning
* The clunky way (using the logical operators `==` and `|`)
* An elegant way (using `%in%`)

See whether you can come up with all three and explain how they (don’t) work.

```{r}
# incorrect command using only `==` goes here
```

This doesn’t work because...

```{r}
# clunky command using `==` and `|` goes here
```

This works because...

```{r}
# elegant command using `%in%` goes here
```

This works because...

#### Challenge 7

Given the following code:

```{r}
m <- matrix(1:18, nrow=3, ncol=6)
```

Which of the following commands will extract the values 11 and 14?

1. `m[2,4,2,5]`

2. `m[2:5]`

3. `m[4:5,2]`

4. `m[2,c(4,5)]`

Your answer: 

#### Challenge 8

Given the following list:

```{r}
xlist <- list(a = "Software Carpentry", b = 1:10, data = head(mtcars))
```

Using your knowledge of both list and vector subsetting, extract the number 2 from xlist.

```{r}
# your command goes here
```

#### Challenge 9

Given a linear model:

```{r}
mod <- aov(pop ~ lifeExp, data=gapminder)
```

Extract the residual degrees of freedom (hint: `attributes()` will help you).

```{r}
# your command goes here
```

#### Challenge 10

Fix each of the following common data frame subsetting errors:

```{r}
# Extract observations collected for the year 1957
gapminder[gapminder$year = 1957,]

# Extract all columns except 1 through to 4
gapminder[,-1:4]

# Extract the rows where the life expectancy is longer the 80 years
gapminder[gapminder$lifeExp > 80]

# Extract the first row, and the fourth and fifth columns (continent and lifeExp).
gapminder[1, 4, 5]

# Advanced: extract rows that contain information for the years 2002 and 2007
gapminder[gapminder$year == 2002 | 2007,]
```

#### Challenge 11

Why does `gapminder[1:20]` return an error? How does it differ from `gapminder[1:20, ]`?

*Your answer goes here.*

Create a new data.frame called `gapminder_small` that only contains rows 1 through 9 and 19 through 23. You can do this in one or two steps.

```{r}
# your commands go here
```
